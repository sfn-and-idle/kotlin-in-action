# 9. ì œë„¤ë¦­ìŠ¤

# 9. ì œë„¤ë¦­ìŠ¤

- ëª©ì°¨
    - ì œë„¤ë¦­ í•¨ìˆ˜ì™€ í´ë˜ìŠ¤ë¥¼ ì •ì˜í•˜ëŠ” ë°©ë²•
    - íƒ€ì… ì†Œê±°ì™€ ì‹¤ì²´í™”í•œ íƒ€ì… íŒŒë¼ë¯¸í„°
    - ì„ ì–¸ ì§€ì ê³¼ ì‚¬ìš© ì§€ì  ë³€ì„±
- ìƒˆë¡œìš´ ë‚´ìš©
    - ì‹¤ì²´í™”í•œ íƒ€ì… íŒŒë¼ë¯¸í„°: reified type parameter
        - ì¸ë¼ì¸ í•¨ìˆ˜ í˜¸ì¶œì—ì„œ íƒ€ì… ì¸ìë¡œ ì“°ì¸ êµ¬ì²´ì ì¸ íƒ€ì…ì„ ì‹¤í–‰ ì‹œì ì— ì•Œ ìˆ˜ ìˆìŒ
    - ì„ ì–¸ ì§€ì  ë³€ì„±: declaration site variance
        - subtype/supertypeì„ ì§€ì •í•  ìˆ˜ ìˆë‹¤
            - List<String>ì„ List<Any>ì²˜ëŸ¼ ì·¨ê¸‰í•  ìˆ˜ ìˆìŒ
    - ì‚¬ìš© ì§€ì  ë³€ì„±: use site variance
        - ì œë„¤ë¦­ íƒ€ì… ê°’ì„ ì‚¬ìš©í•˜ëŠ” ìœ„ì¹˜ì—ì„œ íŒŒë¼ë¯¸í„° íƒ€ì…ì— ëŒ€í•œ ì œì•½ì„ í‘œì‹œí•˜ëŠ” ë°©ì‹
        - ìë°” ì™€ì¼ë“œì¹´ë“œí•˜ê³  ê°™ì€ ì—­í• 

# 9.1 ì œë„¤ë¦­ íƒ€ì… íŒŒë¼ë¯¸í„°

- ì œë„¤ë¦­ì„ ì‚¬ìš©í•´ì„œ íƒ€ì… íŒŒë¼ë¯¸í„°(type parameter)ì„ ë°›ëŠ” íƒ€ì…ì„ ì •ì˜í•  ìˆ˜ ìˆë‹¤
    
    ```kotlin
    List<String>
    Map<String, Person>
    val authors = listOf("Dmitry", "Svetlana")
    val readers: MutableList<String> = mutableListOf()
    val readers = mutableListOf<String>()
    ```
    
    - ìë°”ì—ì„œëŠ” í•˜ìœ„í˜¸í™˜ì„±ì„ ìœ„í•´ íƒ€ì… ì¸ì ì—†ëŠ” ì œë„¤ë¦­íƒ€ì…(raw type)ì˜ ë³€ìˆ˜ë¥¼ ì„ ì–¸í•  ìˆ˜ ìˆë‹¤
    - ì½”í‹€ë¦°ì—ì„œ ì œë„¤ë¦­ íƒ€ì…ì˜ íƒ€ì…ì¸ìë¥¼ í•„ìˆ˜ì ìœ¼ë¡œ ì •ì˜í•´ì•¼í•œë‹¤. íƒ€ì… ì¶”ë¡ ì´ ê°€ëŠ¥í•  ê²½ìš° ìƒëµí•´ë„ ëœë‹¤

## 9.1.1 ì œë„¤ë¦­ í•¨ìˆ˜ì™€ í”„ë¡œí¼í‹°

- ê³µìš©ìœ¼ë¡œ ì‚¬ìš©í•˜ê¸° ìœ„í•œ ë¦¬ìŠ¤íŠ¸ë¥¼ ë‹¤ë£¨ëŠ” í•¨ìˆ˜. ìˆ˜ì‹  ê°ì²´ì™€ ë°˜í™˜ íƒ€ì…ì— List<T>ë¥¼ ì‚¬ìš©í•œë‹¤
    
    ![Untitled](9%20%E1%84%8C%E1%85%A6%E1%84%82%E1%85%A6%E1%84%85%E1%85%B5%E1%86%A8%E1%84%89%207bba6/Untitled.png)
    
- ì œë„¤ë¦­ íƒ€ì… ì¶”ë¡ 
    
    ```kotlin
    >>> val letters = ('a'..'z').toList()
    >>> println(letters.slice<Char>(0..2)) // íƒ€ì… ì¸ìë¥¼ ëª…ì‹œì ìœ¼ë¡œ ì§€ì •
    [a, b, c]
    >>> println(letters.slice(10..13)) // ì»´íŒŒì¼ëŸ¬ëŠ” ì—¬ê¸°ì„œ Tê°€ Charë¼ëŠ” ì‚¬ì‹¤ì„ ì¶”ë¡ 
    [k, l, m, n]
    ```
    
- í•„í„° í•¨ìˆ˜ì—ì„œ ë¦¬ìŠ¤íŠ¸ì˜ ì œë„¤ë¦­ íƒ€ì…ì´ Stringì¸ê²ƒì„ ì¶”ë¡ í•œë‹¤
    
    ```kotlin
    val authors = listOf("Dmitry", "Svetlana")
    val readers = mutableListOf<String>(/* ... */)
    fun <T> List<T>.filter(predicate: (T) -> Boolean): List<T>
    
    // Type inference, í™•ì¥ í•¨ìˆ˜ì—ì„œ íƒ€ì… íŒŒë¼ë¯¸í„°/ìˆ˜ì‹  ê°ì²´ë¥¼ ì‚¬ìš©í•  ìˆ˜ ìˆìŒ
    >>> readers.filter { it !in authors }
    ```
    
- ì œë„¤ë¦­ í™•ì¥ í”„ë¡œí¼í‹° ì •ì˜ ê°€ëŠ¥
    
    ```kotlin
    // ëª¨ë“  ë¦¬ìŠ¤íŠ¸ì—ì„œ ì‚¬ìš©í•  ìˆ˜ ìˆìŒ
    val <T> List<T>.penultimate: T
        get() = this[size - 2]
    
    >>> println(listOf(1, 2, 3, 4).penultimate) // TëŠ” Intë¡œ ì¶”ë¡  ê°€ëŠ¥
    3
    ```
    
    <aside>
    ğŸ’¡ í™•ì¥ í”„ë¡œí¼í‹°ë§Œ ì œë„¤ë¦­í•˜ê²Œ ë§Œë“¤ ìˆ˜ ìˆë‹¤
    í´ë˜ìŠ¤ í”„ë¡œí¼í‹°ì— ì—¬ëŸ¬ íƒ€ì… ê°’ì„ ì €ì¥ í•  ìˆ˜ ì—†ë‹¤
    
    </aside>
    

## 9.1.2 ì œë„¤ë¦­ í´ë˜ìŠ¤ ì„ ì–¸

- ì œë„¤ë¦­ í´ë˜ìŠ¤ ì„ ì–¸: ìë°”ë€ ë¬¸ë²• ê°™ë‹¤ `<>`
- í´ë˜ìŠ¤ë‘ ì¸í„°í˜ì´ìŠ¤ë¥¼ ì œë„¤ë¦­í•˜ê²Œ ë§Œë“¤ ìˆ˜ ìˆìŒ
    
    ```kotlin
    interface List<T> {
    	operator fun get(index: Int) : T
    }
    ```
    
- ì œë„¤ë¦­ í´ë˜ìŠ¤ë¥¼ í™•ì¥í•˜ëŠ” í´ë˜ìŠ¤/ì¸í„°í˜ì´ìŠ¤
    
    ```kotlin
    // êµ¬ì²´ì ì¸ íƒ€ì…ì„ ì§€ì • í•  ìˆ˜ ìˆë‹¤
    class StringList: List<String> {
    		// ì—¬ê¸°ì„œ ë°˜í™˜ íƒ€ì…ë„ ìŠ¤íŠ¸ë§ìœ¼ë¡œ ì •ì˜ í•´ì¤€ë‹¤
        override fun get(index: Int): String = ...  
    }
    
    // íƒ€ì…ì„ ê·¸ëŒ€ë¡œ ë„˜ê¸¸ ìˆ˜ ìˆë‹¤
    class ArrayList<T> : List<T> {
        override fun get(index: Int): T = ...
    }
    ```
    
- Comparableì˜ˆ
    
    ```kotlin
    interface Comparable<T> {
        fun compareTo(other: T): Int
    }
    
    // String íƒ€ì… ì¸ì + í•¨ìˆ˜ ì¸ì, Stringí´ë˜ìŠ¤ ë³¸ì¸ì„ Comparableì— ë„˜ê¸¸ ìˆ˜ ìˆë‹¤
    class String : Comparable<String> {
        override fun compareTo(other: String): Int = /* ... */
    }
    ```
    

## 9.1.3 íƒ€ì… íŒŒë¼ë¯¸í„° ì œì•½

- íƒ€ì… íŒŒë¼ë¯¸í„° ì œì•½: type parameter constraint
    - í´ë˜ìŠ¤ë‚˜ í•¨ìˆ˜ì— ì‚¬ìš©í•  ìˆ˜ ìˆëŠ” íƒ€ì… ì¸ìë¥¼ ì œí•œí•˜ëŠ” ê¸°ëŠ¥
    - íƒ€ì… íŒŒë¼ë¯¸í„°ì— ëŒ€í•œ ìƒí•œ: upper bound
        - í•˜ìœ„ íƒ€ì…: subtype
        - í•˜ìœ„ í´ë˜ìŠ¤: subclass
        - ìƒí•œ íƒ€ì…ìœ¼ë¡œ ì œì•½ì„ ê°€í•˜ê¸°
            
            ```kotlin
            // Numberê°€ ìƒí•œ, Intë‚˜ Double ì œë„¤ë¦­ íƒ€ì…ì„ ê°€ì§„ ë¦¬ìŠ¤íŠ¸ì—ì„œ ì‚¬ìš© í•  ìˆ˜ ìˆëŠ” í•¨ìˆ˜
            // ë¬¸ë²•: `:`ì‚¬ìš©
            fun <T : Number> List<T>.sum(): T
            
            println(listOf(1,2,3).sum())
            6
            
            fun <T : Number> oneHalf(value: T): Double {
            		// Number.toDouble()ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤
                return value.toDouble() / 2.0
            }
            >>> println(oneHalf(3))
            1.5
            ```
            
    - íƒ€ì… íŒŒë¼ë¯¸í„°ë¥¼ ì œì•½í•˜ëŠ” í•˜ë¬´ ì„ ì–¸í•˜ê¸°
        
        ```kotlin
        fun <T: Comparable<T>> max(first: T, second: T): T {
        	return if (first > second) first else second
        }
        
        >>> println(max("kotlin", "java"))
        kotlin
        
        // ì œì•½ ì¡°ê±´ì„ ì¶©ì¡±í•˜ì§€ ëª»í•˜ëŠ” ìƒí™©ì—ì„œ max()ë¥¼ í˜¸ì¶œ í•  ê²½ìš°
        >>> println(max("kotlin", 42))
        ERROR: Type parameter bound for T is not satisfied:
         inferred type Any is not a subtype of Comparable<Any>
        ```
        
    - ì—¬ëŸ¬ ìƒí•œ ì œì•½ ì¡°ê±´ì„ ê±¸ì–´ì•¼í•  ê²½ìš°
        
        ```kotlin
        // StringBuilder, CharBuffer, ë“±
        fun <T> ensureTrailingPeriod(seq: T) where T : CharSequence, T : Appendable {
        	// endsWithì‚¬ìš©
        	if (!seq.endsWith('.')) {
        		// appendì‚¬ìš©
        		seq.append('.')
        	} 
        }
        
        >>> val helloWorld = StringBuilder("Hello World")
        >>> ensureTrailingPeriod(helloWorld)
        >>> println(helloWorld)
        Hello World.
        ```
        

## 9.1.4 íƒ€ì… íŒŒë¼ë¯¸í„°ë¥¼ ë„ì´ ë  ìˆ˜ ì—†ëŠ” íƒ€ì…ìœ¼ë¡œ í•œì •

- Nullableíƒ€ì…ì„ ì œë„¤ë¦­ì—ì„œ ì‚¬ìš© ê°€ëŠ¥
- ìƒí•œì„ ì •í•˜ì§€ ì•Šìœ¼ë©´ ìƒí•œì€ Any?ë¡œ ì§€ì •ëœë‹¤
- Nullable Type
    
    ```kotlin
    class Processor<T> {
        fun process(value: T) {
            value?.hashCode()
        }
    }
    
    val nullableStringProcessor = Processor<String?>()
    nullableStringProcessor.process(null)
    
    // ?ë¥¼ ì œê±°í•˜ë©´ Nonnullì´ ëœë‹¤
    class Processor<T : Any> {
        fun process(value: T) {
            value.hashCode()
        }
    }
    >>> val nullableStringProcessor = Processor<String?>()
    Error: Type argument is not within its bounds: should be subtype of 'Any'
    ```
    

# 9.2 ì‹¤í–‰ ì‹œ ì œë„¤ë¦­ìŠ¤ì˜ ë™ì‘: ì†Œê±°ëœ íƒ€ì… íŒŒë¼ë¯¸í„°ì™€ ì‹¤ì²´í™”ëœ íƒ€ì… íŒŒë¼ë¯¸í„°

- JVMì˜ ì œë„¤ë¦­ìŠ¤ëŠ” ë³´í†µ íƒ€ì… ì†Œê±°(Type Erasure)ì„ ì‚¬ìš©í•´ êµ¬í˜„ëœë‹¤
- ì‹¤í–‰ ì‹œì ì— ì œë„¤ë¦­ í´ë˜ìŠ¤ì˜ ì¸ìŠ¤í„´ìŠ¤ì— íƒ€ì… ì¸ì ì •ë³´ê°€ ë“¤ì–´ìˆì§€ ì•ŠìŒ
- ì½”í‹€ë¦° inlineí•¨ìˆ˜ ì‚¬ìš©ìœ¼ë¡œ íƒ€ì… ì†Œê±°ë¥¼ ìš°íšŒí•  ìˆ˜ ìˆìŒ
    - ì‹¤ì²´í™”: reify

## 9.2.1 ì‹¤í–‰ ì‹œì ì˜ ì œë„¤ë¦­: íƒ€ì… ê²€ì‚¬ì™€ ìºìŠ¤íŠ¸

- List<String>ì€ ì‹¤í–‰ ì‹œì ì— Listë¡œë§Œ ë³¼ ìˆ˜ ìˆë‹¤
    - ì›ì†Œë¥¼ ì–»ì–´ì™€ì„œ ê²€ì‚¬ë¥¼ í†µí•´ íƒ€ì…ì„ ì°¾ì„ ìˆ˜ ìˆì§€ë§Œ ì—¬ëŸ¬ ì›ì†Œê°€ ë‹¤ë¥¸ íƒ€ì…ì´ ë  ìˆ˜ë„ ìˆë‹¤
- ë¹„êµ
    
    ```kotlin
    val list1: List<String> = listOf("a", "b")
    val list2: List<Int> = listOf(1, 2, 3)
    ```
    
    ![Untitled](9%20%E1%84%8C%E1%85%A6%E1%84%82%E1%85%A6%E1%84%85%E1%85%B5%E1%86%A8%E1%84%89%207bba6/Untitled%201.png)
    
- ì»´íŒŒì¼ëŸ¬ê°€ ì›ì†Œì˜ íƒ€ì… ê²€ì‚¬í•˜ê³  ë³´ì¥í•´ì¤€ë‹¤ (rawíƒ€ì…ê³¼ ìºìŠ¤íŒ…ì„ í†µí•´ì„œ ì»´íŒŒì¼ëŸ¬ë¥¼ ì†ì¼ ìˆ˜ ìˆë‹¤)
- ì‹¤í–‰ ì‹œì ì—ì„œ ë¦¬ìŠ¤íŠ¸ì˜ ì›ì†Œ íƒ€ì…ìœ¼ë¡œ ì´ë¤„ì ¸ìˆëŠ”ì§€ ì•Œ ìˆ˜ ì—†ë‹¤
- isê²€ì‚¬ì—ì„œ íƒ€ì… ì¸ìë¡œ ì§€ì •í•œ íƒ€ì…ì„ ê²€ì‚¬í•  ìˆ˜ ì—†ë‹¤
    
    ```kotlin
    >>> if (value is List<String>) { ... }
    ERROR: Cannot check for instance of erased type
    ```
    
- íƒ€ì… ì†Œê±°ë¥¼ í†µí•´ í”„ë¡œê·¸ë¨ì´ ì‚¬ìš©í•˜ëŠ” ë©”ë©”ë¡œë¥¼ ì¤„ì¼ ìˆ˜ ìˆë‹¤
- ìŠ¤íƒ€ í”„ë¡œì ì…˜: star projection
    
    ```kotlin
    // java: List<?>
    if (value is List<*>)
    ```
    
- asë‚˜ as?
    
    ```kotlin
    fun printSum(c: Collection<*>) {
    	val intList = c as? List<Int> // Warning here. Unchecked cast: List<*> to List<Int>
    		?: throw IllegalArgumentException("List is expected")
    println(intList.sum())
    }
    >>> printSum(listOf(1, 2, 3))
    6
    Everything works as expected.
    
    >>> printSum(setOf(1, 2, 3))
    IllegalArgumentException: List is expected
    
    >>> printSum(listOf("a", "b", "c"))
    ClassCastException: String cannot be cast to Number
    
    // ì½”í‹€ë¦° ì»´íŒŒì¼ëŸ¬ëŠ” isë¥¼ ë‹¤ìŒ ì²˜ëŸ¼ ì‚¬ìš©í•  ìˆ˜ ìˆì„ ì •ë„ë¡œ ë˜‘ë˜‘í•˜ë‹¤
    fun printSum(c: Collection<Int>) {
        if (c is List<Int>) {
            println(c.sum())
        }
    }
    >>> printSum(listOf(1, 2, 3))
    6
    ```
    
- ì•ˆì „í•˜ì§€ ëª»í•œ isê²€ì‚¬ëŠ” ê¸ˆì§€í•˜ê³  ìœ„í—˜í•œ asìºìŠ¤íŒ…ì€ ê²½ê³ ë¥¼ ì¶œë ¥í•œë‹¤

## 9.2.2 ì‹¤ì²´í™”í•œ íƒ€ì… íŒŒë¼ë¯¸í„°ë¥¼ ì‚¬ìš©í•œ í•¨ìˆ˜ ì„ ì–¸

- ì½”í‹€ë¦° ì œë„¤ë¦­ íƒ€ì…ì˜ íƒ€ì… ì¸ì ì •ë³´ëŠ” ì‹¤í–‰ ì‹œì ì— ì§€ì›Œì§„ë‹¤
- ì œë„¤ë¦­ í´ë˜ìŠ¤ ì¸ìŠ¤í„´ìŠ¤ê°€ ìˆì–´ë„ ì‹¤í–‰ ì‹œì ì— ì¸ìŠ¤í„´ìŠ¤ë¥¼ ë§Œë“¤ ë•Œ ì‚¬ìš©í•œ íƒ€ì… ì¸ìë¥¼ ì•Œì•„ë‚¼ ìˆ˜ ì—†ë‹¤
    - ì œë„¤ë¦­ í•¨ìˆ˜ íƒ€ì… ì¸ìë„ ë˜‘ê°™ë‹¤(í•¨ìˆ˜ ë³¸ë¬¸ì—ì„œë„ íƒ€ì… ì¸ìë¥¼ ì•Œ ìˆ˜ ì—†ë‹¤)
        
        ```kotlin
        >>> fun <T> isA(value: Any) = value is T
        Error: Cannot check for instance of erased type: T
        ```
        
- inlineí•¨ìˆ˜(íƒ€ì… ì¸ìë¥¼ ì•Œ ìˆ˜ ìˆìŒ)
    
    ```kotlin
    ì‹¤ì²´í™”í•œ íƒ€ì… íŒŒë¼ë¯¸í„°ë¥¼ ì‚¬ìš©í•˜ëŠ” í•¨ìˆ˜ ì •ì˜í•˜ê¸°
    
    inline fun <reified T> isA(value: Any) = value is T // "is T"ë¶€ë¶„ ì‚¬ìš© ê°€ëŠ¥
    
    >>> println(isA<String>("abc"))
    true
    >>> println(isA<String>(123))
    false
    ```
    
- í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬ filterIsInstanceí•¨ìˆ˜
    
    ```kotlin
    ////////////////////////////////////////////////////////////
    // í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬ ì†ŒìŠ¤
    ////////////////////////////////////////////////////////////
    public inline fun <reified R> Iterable<*>.filterIsInstance(): List<@kotlin.internal.NoInfer R> {
        return filterIsInstanceTo(ArrayList<R>())
    }
    
    public inline fun <reified R, C : MutableCollection<in R>> Iterable<*>.filterIsInstanceTo(destination: C): C {
        for (element in this) if (element is R) destination.add(element)
        return destination
    }
    
    ////////////////////////////////////////////////////////////
    // ì˜ˆì œ
    ////////////////////////////////////////////////////////////
    >>> val items = listOf("one", 2, "three")
    >>> println(items.filterIsInstance<String>())
    [one, three]
    ```
    
- ê°„ì†Œí™” í•´ì„œ êµ¬í˜„ëœ filterIsInstanceí•¨ìˆ˜
    
    ```kotlin
    inline fun <reified T> Iterable<*>.filterIsInstance(): List<T> {
    	val destination = mutableListOf<T>()
    	for (element in this) {
    		if (element is T) {
    			destination.add(element)
    		} 
    	}
    
    	return destination
    }
    ```
    
- ì¼ë°˜í•¨ìˆ˜ì—ì„œ íƒ€ì… ì¸ìë¥¼ ëª» ì“°ê³  inlineí•¨ìˆ˜ì—ì„œ ì‚¬ìš©í•  ìˆ˜ ìˆëŠ” ì´ìœ 
    
    <aside>
    ğŸ’¡ inlineí•¨ìˆ˜ê°€ í˜¸ì¶œ ë˜ëŠ” ëª¨ë“  ì§€ì ì— ì½”ë“œê°€ ì‚½ì…ëœë‹¤
    ì»´íŒŒì¼ëŸ¬ëŠ” íƒ€ì… ì¸ìë¡œ ì“°ì¸ êµ¬ì²´ì ì¸ í´ë˜ìŠ¤ë¥¼ ì°¸ì¡°í•˜ëŠ” ë°”ì´íŠ¸ì½”ë“œë¥¼ ìƒì„±í•´ ì‚½ì…í•  ìˆ˜ ìˆë‹¤
    
    filterIsInstance<String>
    for (element in this) {
      if (element is String) {
        destination.add(element)
      }
    }
    
    êµ¬ì²´ì ì¸ íƒ€ì…ì„ ì‚¬ìš©í•˜ëŠ” ë°”ì´íŠ¸ ì½”ë“œëŠ” íƒ€ì… ì†Œê±°ì˜ ì˜í–¥ì„ ë°›ì§€ ì•ŠëŠ”ë‹¤
    
    ìë°” ì½”ë“œì—ì„œ reifiedíƒ€ì… íŒŒë¼ë¯¸í„°ë¥¼ ì‚¬ìš©í•˜ëŠ” inlineí•¨ìˆ˜ë¥¼ í˜¸ì¶œ í•  ìˆ˜ ì—†ë‹¤
    ìë°”ì—ì„œ ì½”í‹€ë¦° ì¸ë¼ì¸ í•¨ìˆ˜ë¥¼ ë‹¤ë¥¸ ë³´í†µ í•¨ìˆ˜ ì²˜ëŸ¼ í˜¸ì¶œ í•œë‹¤
    
    </aside>
    
- inlineí•¨ìˆ˜ë¥¼ ì‚¬ìš©í•´ì„œ ì„±ëŠ¥ ê°œì„ ì„ í•  ìˆ˜ë„ ìˆì§€ë§Œ ì¶”ê°€ì ìœ¼ë¡œ ì‹¤ì²´í™” ëœ íƒ€ì…ì„ ì‚¬ìš©í•˜ê¸° ìœ„í•´ì„œ ì‚¬ìš© í•  ìˆ˜ë„ ìˆë‹¤
    
    

## 9.2.3 ì‹¤ì²´í™”í•œ íƒ€ì… íŒŒë¼ë¯¸í„°ë¡œ í´ë˜ìŠ¤ ì°¸ì¡° ëŒ€ì‹ 

- Service::class.javaêµ¬ë¬¸ì€ Service.classìë°” ì½”ë“œì™€ ì™„ì „íˆ ê°™ë‹¤
    
    ```kotlin
    val serviceImpl = ServiceLoader.load(Service::class.java)
    
    val serviceImpl = loadService<Service>()
    
    inline fun <reified T> loadService() { // reifiedì‚¬ìš©
        return ServiceLoader.load(T::class.java) // T::class.javaì‚¬ìš©
    }
    ```
    
- ì•ˆë“œë¡œì´ë“œ ì˜ˆì œ
    
    ```kotlin
    inline fun <reified T : Activity> Context.startActivity() {
        val intent = Intent(this, T::class.java)
        startActivity(intent)
    }
    startActivity<DetailActivity>()
    ```
    

## 9.2.4 ì‹¤ì²´í™”í•œ íƒ€ì… íŒŒë¼ë¯¸í„°ì˜ ì œì•½

- ë‹¤ìŒ ê²½ìš°ì—ì„œ ì‹¤ì²´í™”í•œ íƒ€ì… íŒŒë¼ë¯¸í„°ë¥¼ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤
    - íƒ€ì… ê²€ì‚¬ì™€ ìºìŠ¤íŒ…(is, !is, as, as?)
    - ì½”í‹€ë¦° ë¦¬í”Œë ‰ì…˜ API(::class)
    - ì½”í‹€ë¦° íƒ€ì…ì— ëŒ€ì‘í•˜ëŠ” java.lang.Classë¥¼ ì–»ê¸° ìœ„í•´(::class.java)
    - ë‹¤ë¥¸ í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•  ë•Œ íƒ€ì… ì¸ìë¡œ ì‚¬ìš©
- í•  ìˆ˜ ì—†ëŠ” ì¼
    - íƒ€ì… íŒŒë¼ë¯¸í„° í´ë˜ìŠ¤ì˜ ì¸ìŠ¤í„´ìŠ¤ ìƒì„±í•˜ê¸°
    - íƒ€ì… íŒŒë¼ë¯¸í„° í´ë˜ìŠ¤ì˜ ë™ë°˜ ê°ì²´ ë©”ì†Œë“œ í˜¸ì¶œí•˜ê¸°
    - ì‹¤ì²´í™”í•œ íƒ€ì… íŒŒë¼ë¯¸í„°ë¥¼ ìš”êµ¬í•˜ëŠ” í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•˜ë©´ì„œ ì‹¤ì²´í™”í•˜ì§€ ì•Šì€ íƒ€ì… íŒŒë¼ë¯¸í„°ë¡œ ë°”ë“  íƒ€ì…ì„ íƒ€ì… ì¸ìë¡œ ë„˜ê¸°ê¸°
    - í´ë˜ìŠ¤, í”„ë¡œí¼í‹°, ì¸ë¼ì¸ í•¨ìˆ˜ê°€ ì•„ë‹Œ í•¨ìˆ˜ì˜ íƒ€ì… íŒŒë¼ë¯¸í„°ë¥¼ reifiedë¡œ ì§€ì •í•˜ê¸°
        - inlineí•¨ìˆ˜ì—ì„œë§Œ ì‹¤ì²´í™”í•œ íƒ€ì… íŒŒë¼ë¯¸í„°ë¥¼ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤. ì´ì— ë”°ë¼ í•¨ìˆ˜ë‘ í•¨ìˆ˜ì˜ ëª¨ë“  ì¸ì(ëŒë‹¤ í¬í•¨)ì€inlineëœë‹¤. inlineí•¨ìˆ˜ì—ì„œ ëŒë‹¤ë¥¼ ì‚¬ìš©í•˜ëŠ” ë°©ì‹ ë•Œë¬¸ì— ëŒë‹¤ê°€ inlineì²˜ë¦¬ ë  ìˆ˜ ì—†ë‹¤ë©´(ë˜ëŠ” ì„±ëŠ¥ì„ ìœ„í•´ ê°œë°œìê°€ inlineì²˜ë¦¬ë¥¼ ì›í•˜ì§€ ì•Šë‹¤ë©´) noinlineë³€ê²½ìë¥¼ ì‚¬ìš©í•˜ë©´ ëœë‹¤.
        - 

# 9.3 ë³€ì„±: ì œë„¤ë¦­ê³¼ í•˜ìœ„ íƒ€ì…

- ë³€ì„±
    - ê°™ì€ ê¸°ì €íƒ€ì…(Base Type)ì´ì§€ë§Œ íƒ€ì… ì¸ìê°€ ë‹¤ë¥¼ ê²½ìš° List<String>, List<Any>
        - ê´€ê³„ì— ëŒ€í•´ì„œ ì‚´í´ë³´ê¸°

## 9.3.1 ë³€ì„±ì´ ìˆëŠ” ì´ìœ : ì¸ìë¥¼ í•¨ìˆ˜ì— ë„˜ê¸°ê¸°

- fun a(a: Any), Stringì„ ì¸ìë¡œ ë„˜ê¸¸ ìˆ˜ ìˆì§€ë§Œ íƒ€ì… íŒŒë¼ë¯¸í„°ì¼ ê²½ìš°?

```jsx
fun printContents(list: List<Any>) {
	println(list.joinToString())
}

>>> printContents(listOf("abc", "bac"))
abc, bac
```

- ì½”í‹€ë¦° ì»´íŒŒì¼ëŸ¬ëŠ” ë‹¤ìŒì„ ë§‰ëŠ”ë‹¤

```jsx
// MutableList<String>, MutableList<Any>

fun addAnswer(list: MutableList<Any>) {
	list.add(42)
}

>>> val strings = mutableListOf("abc", "bac")
>>> addAnswer(strings)
>>> println(strings.maxBy { it.length })
ClassCastException: Integer cannot be cast to String
```

## 9.3.2 í´ë˜ìŠ¤, íƒ€ì…, í•˜ìœ„ íƒ€ì…

- ì œë„¤ë¦­ì´ ì•„ë‹Œ í´ë˜ìŠ¤ì—ì„œëŠ” ë³€ìˆ˜ë¥¼ ì„ ì–¸í•  ë•Œ í´ë˜ìŠ¤ë¥¼ ë°”ë¡œ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤
    - ì½”í‹€ë¦° í´ë˜ìŠ¤
        - var x: String
        - nullable
            - var x: String?
        - ëª¨ë“  ì½”í‹€ë¦° í´ë˜ìŠ¤ëŠ” ì ì–´ë„ íƒ€ì… 2ê°œë¥¼ ì •ì˜í•  ìˆ˜ ìˆë‹¤
    - ì œë„¤ë¦­ì„ ì‚¬ìš©í•œ í´ë˜ìŠ¤
        - List<Int>, List<String?>, List<<List<String>>
        - ë¬´í•œìœ¼ë¡œ íƒ€ì…ì´ ì •ì˜ ë  ìˆ˜ ìˆë‹¤
- subtype
    - O: Number > Int, Int > Int
    - X: String > Int
- supertype
    - subtypeì˜ ë°˜ëŒ€ë§
    - Aê°€ Bì˜ subtypeì´ë©´, Bê°€ Aì˜ supertypeì´ë‹¤
        
        ![Untitled](9%20%E1%84%8C%E1%85%A6%E1%84%82%E1%85%A6%E1%84%85%E1%85%B5%E1%86%A8%E1%84%89%207bba6/Untitled%202.png)
        
- ë³€ìˆ˜ì— ê°’ì„ ì§€ì •í•˜ë©´ ì»´íŒŒì¼ëŸ¬ê°€ subtype/supertypeì„ ë§¤ë²ˆ í™•ì¸í•œë‹¤
    
    ```kotlin
    fun test(i: Int) {
    	// O
    	val n: Number = i
    
    	// X
    	fun f(s: String) { /*...*/ }
    	f(i) 
    }
    ```
    
- ê°„ë‹¨í•œ ê²½ìš°ì—ì„œ subtypeì€ subclassí•˜ê³  ê°™ì€ ê°œë…ì´ë¼ê³  ë³¼ ìˆ˜ ìˆë‹¤
    - Number > Int (Subtype/Subclass)
    - CharSequence > String (Subtype/Subclass, interface implement)
- Nullable Subtype
    
    ![Untitled](9%20%E1%84%8C%E1%85%A6%E1%84%82%E1%85%A6%E1%84%85%E1%85%B5%E1%86%A8%E1%84%89%207bba6/Untitled%203.png)
    
- ì œë„¤ë¦­ íƒ€ì…, subtype/supertypeì˜ ì¤‘ìš”ì„±
    - O: Nullable > NonNull, X: NonNull > Nullable
    - X: MutableList<Any>   >>>   MutableList<String>
    - X: MutableList<String>   >>>   MutableList<Any>
- ë¬´ê³µë³€(invariant)
    - MutableList, Type A, Type B, íƒ€ì… íŒŒë¼ë¯¸í„°ì— ì˜ì¡´
        - MutableList<A>ëŠ” í•­ìƒ MutableList<B>ì˜ í•˜ìœ„ íƒ€ì…ì´ ì•„ë‹ˆë‹¤
- ê³µë³€ì (covariant)
    - List
        - B   >>>   A
        - List<B>   >>>   List<A>

## 9.3.3 ê³µë³€ì„±: í•˜ìœ„ íƒ€ì… ê´€ê³„ë¥¼ ìœ ì§€

- ê³µë³€ì  ì œë„¤ë¦­ í´ë˜ìŠ¤
    - íƒ€ì… ê´€ê³„ê°€ ìœ ì§„ëœë‹¤ê³  ë§í•  ìˆ˜ ìˆëŠ” ê²½ìš°
        
        ```kotlin
        Producer<T>
        
        Producer<B> >>> Producer<A>
        B >>> A
        
        Producer<Animal> >>> Producer<Cat>
        Animal >>> Cat
        ```
        
- â€œoutâ€ì„ ì‚¬ìš©í•´ì„œ ê³µë³€ì ì„ì„ í‘œì‹œí•œë‹¤. íƒ€ì… íŒŒë¼ë¯¸í„°ê°€ ì •í™•íˆ ì¼ì¹˜í•˜ì§€ ì•Šì•„ë„ í•¨ìˆ˜ ì¸ìë¡œ ë„˜ê¸¸ ìˆ˜ ìˆë‹¤.
    
    ```kotlin
    interface Producer<out T> {
        fun produce(): T
    }
    
    // ì˜ˆì œ
    open class Animal {
        fun feed() { ... }
    }
    
    class Herd<T : Animal> { // The type parameter isnâ€™t declared as covariant.
        val size: Int get() = ...
        operator fun get(i: Int): T { ... }
    }
    
    fun feedAll(animals: Herd<Animal>) {
        for (i in 0 until animals.size) {
            animals[i].feed()
        }
    }
    
    // ì˜¤ë¥˜
    class Cat : Animal() { // A Cat is an Animal.
        fun cleanLitter() { ... }
    }
    fun takeCareOfCats(cats: Herd<Cat>) {
        for (i in 0 until cats.size) {
            cats[i].cleanLitter()
            // feedAll(cats)
        }
    }
    >>> X: Herd<Animal> >>> Herd<Cat>
    >>> Error: inferred type is Herd<Cat>, but Herd<Animal> was expected
    
    // ê³µë³€ì ìœ¼ë¡œ ì œë„¤ë¦¬ íƒ€ì…ì„ ì •ì˜
    class Herd<out T : Animal> { // The T parameter is now covariant.
       ...
    }
    fun takeCareOfCats(cats: Herd<Cat>) {
        for (i in 0 until cats.size) {
            cats[i].cleanLitter()
        }
        feedAll(cats)
    }
    ```
    
- íƒ€ì… íŒŒë¼ë¯¸í„°ë¥¼ ê³µë³€ì ìœ¼ë¡œ ì§€ì •í•˜ë©´ í´ë˜ìŠ¤ ë‚´ë¶€ì—ì„œ ê·¸ íŒŒë¼ë¯¸í„°ë¥¼ ì‚¬ìš©í•˜ëŠ” ë°©ë²•ì„ ì œí•œí•œë‹¤
- íƒ€ì… ì•ˆì „ì„±ì„ ë³´ì¥í•˜ê¸° ìœ„í•´ ê³µë³€ì  íŒŒë¼ë¯¸í„°ëŠ” í•­ìƒ ì•„ì›ƒ(out)ìœ„ì¹˜ì—ë§Œ ìˆë‹¤
- ì•„ì›ƒ íƒ€ì…ì„ ìƒì‚°í•  ìˆ˜ ìˆì§€ë§Œ ì†Œë¹„í•  ìˆ˜ ì—†ë‹¤
- inìœ„ì¹˜(í•¨ìˆ˜ ì¸ìë¡œ ì‚¬ìš© ë¨), outìœ„ì¹˜(ë°˜í™˜ íƒ€ì…ìœ¼ë¡œ ì‚¬ìš© ë¨)
    
    ![Untitled](9%20%E1%84%8C%E1%85%A6%E1%84%82%E1%85%A6%E1%84%85%E1%85%B5%E1%86%A8%E1%84%89%207bba6/Untitled%204.png)
    
- TëŠ” outìœ„ì¹˜ì—ì„œë§Œ ì‚¬ìš©í•œë‹¤(ë°˜í™˜ íƒ€ì…)
    
    ```kotlin
    class Herd<out T : Animal> {
        val size: Int get() = ...
        operator fun get(i: Int): T { ... }
    }
    ```
    
- outí‚¤ì›Œë“œ
    - subtypingì´ ìœ ì§€ ë¨
        - Producer<Animal> >>> Producer<Cat>
        - TëŠ” outìœ„ì¹˜ì—ì„œë§Œ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤
- List<T>ì¸í„°í˜ì´ìŠ¤
    - ListëŠ” ì½ê¸° ì „ìš©ì´ë‹¤
    - getí•¨ìˆ˜ëŠ” Të¥¼ ë¦¬í„´í•œë‹¤
    - íƒ€ì…Të¡œ ì €ì¥í•˜ëŠ” í•¨ìˆ˜ëŠ” ì—†ë‹¤
    - ê³µë³€ì ì´ë‹¤
    
    ```kotlin
    interface List<out T> : Collection<T> {
       operator fun get(index: Int): T
       // ...
    }
    
    // outìœ„ì¹˜ë¡œ ë‹¤ë¥¸ ì œë„¤ë¦­ íŒŒë¼ë¯¸í„°ë¡œ ë„˜ê¸¸ ìˆ˜ë„ ìˆë‹¤
    interface List<out T> : Collection<T> {
       fun subList(fromIndex: Int, toIndex: Int): List<T>
       // ...
    }
    ```
    
- MutableList<T>ë¥¼ ê³µë³€ì ìœ¼ë¡œ ì •ì˜ í•  ìˆ˜ ì—†ë‹¤. íƒ€ì… Të¥¼ ì¸ìë¡œ ë°›ëŠ” í•œìˆ˜ë“¤ë„ ìˆê³  ë°˜í™˜í•˜ëŠ” í•¨ìˆ˜ë“¤ë„ ìˆë‹¤
    
    ```kotlin
    interface MutableList<T>
           : List<T>, MutableCollection<T> {
    	// in position
    	override fun add(element: T): Boolean
    }
    
    // outìœ¼ë¡œ ì •ì˜í•œë‹¤ë©´ ì˜¤ë¥˜
    // Type parameter T is declared as 'out' but occurs in 'in' position.
    ```
    
- ìƒì„±ìì—ì„œëŠ” íƒ€ì… ìœ„ì¹˜ë‘ ìƒê´€ ì—†ì´ ì‚¬ìš© ê°€ëŠ¥
    
    ```kotlin
    class Herd<out T: Animal>(vararg animals: T) { ... }
    ```
    
- val/varì„ ìƒì„±ìì—ì„œ ì‚¬ìš©í•˜ë©´ ì‚¬ìš©í•˜ë©´ , getter setterì„ ì •ì˜ í•  ìˆ˜ ìˆë‹¤
    
    ```kotlin
    // val: out, var: in/out, TëŠ” outìœ¼ë¡œ ì •ì˜í•  ìˆ˜ ì—†ë‹¤
    class Herd<T: Animal>(var leadAnimal: T, vararg animals: T) { ... }
    ```
    
- ìœ„ì¹˜ì— ëŒ€í•œ ê·œì¹™ì€ public/protected/internalì—ë§Œ ì ìš©ì´ ëœë‹¤
- privateí•¨ìˆ˜ì—ëŠ” in/outìœ„ì¹˜ë¥¼ ë”°ì§€ì§€ ì•ŠëŠ”ë‹¤

## 9.3.4 ë°˜ê³µë³€ì„±: ë’¤ì§‘íŒ í•˜ìœ„ íƒ€ì… ê´€ê³„

- ê³µë³€ì„±ì˜ ë°˜ëŒ€ë¼ê³  ë³¼ ìˆ˜ ìˆë‹¤

```kotlin
interface Comparator<in T>  {
    fun compare(e1: T, e2: T): Int { ... }
}

// Anyì˜ subtypeë¹„êµ ê°€ëŠ¥
>>> val anyComparator = Comparator<Any> {
			e1, e2 -> e1.hashCode() - e2.hashCode()
		}
>>> val strings: List<String> = ...
>>> strings.sortedWith(anyComparator)
```

- íƒ€ì…íŒŒë¼ë¯¸í„°ì— ëŒ€í•´ì„œ ë°˜ê³µë³€ì„±ì„ ê°€ì§„ í´ë˜ìŠ¤ëŠ” ì œë„¤ë¦­ í´ë˜ìŠ¤ë¼ê³  ë¶€ë¥¼ ìˆ˜ ìˆë‹¤
- Consumer<B> >>> Consumer<A>
- A >>> B
    
    ![Untitled](9%20%E1%84%8C%E1%85%A6%E1%84%82%E1%85%A6%E1%84%85%E1%85%B5%E1%86%A8%E1%84%89%207bba6/Untitled%205.png)
    
- ì •ì˜(ê³µë³€, ë°˜ê³µë³€, ë¬´ê³µë³€)

![Untitled](9%20%E1%84%8C%E1%85%A6%E1%84%82%E1%85%A6%E1%84%85%E1%85%B5%E1%86%A8%E1%84%89%207bba6/Untitled%206.png)

- 

```kotlin
// P preserved, R reversed
interface Function1<in P, out R> {
    operator fun invoke(p: P): R
}

// Animal >>> Cat, Number >>> Int
fun enumerateCats(f: (Cat) -> Number) { ... }
fun Animal.getIndex(): Int = ...

>>> enumerateCats(Animal::getIndex)
```

![Untitled](9%20%E1%84%8C%E1%85%A6%E1%84%82%E1%85%A6%E1%84%85%E1%85%B5%E1%86%A8%E1%84%89%207bba6/Untitled%207.png)

## 9.3.5 ì‚¬ìš© ì§€ì  ë³€ì„±: íƒ€ì…ì´ ì–¸ê¸‰ë˜ëŠ” ì§€ì ì—ì„œ ë³€ì„± ì§€ì •

- ì„ ì–¸ ì§€ì  ë³€ì„± declaration site variance
- java wildcard type
    - ? extends
    - ? super
- ì‚¬ìš© ì§€ì  ë³€ì„± use site variance
- java Stream.map
    
    ```kotlin
    /* Java */
    public interface Stream<T> {
        <R> Stream<R> map(Function<? super T, ? extends R> mapper);
    }
    ```
    
- ì‚¬ìš© ì§€ì  ë³€ì„± ì˜ˆì œ
    
    ```kotlin
    // Collection<String> >>> Collection<Object>
    fun <T> copyData(
    	source: MutableList<T>, // reading, ë¬´ê³µë³€(invariant)
    	destination: MutableList<T> // writing, ë¬´ê³µë³€(invariant)
    ) {
    	for (item in source) {
    		destination.add(item)
    	} 
    }
    ```
    
- ë‘ë²ˆì§¸ ì œë„¤ë¦­ íŒŒë¼ë¯¸í„°ë¥¼ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤
    
    ```kotlin
    // T extends R, R,
    fun <T: R, R> copyData(
    	source: MutableList<T>,
    	destination: MutableList<R>
    ) {
    	for (item in source) {
    	    destination.add(item)
    	} 
    }
    >>> val ints = mutableListOf(1, 2, 3)
    >>> val anyItems = mutableListOf<Any>()
    >>> copyData(ints, anyItems)
    >>> println(anyItems)
    [1, 2, 3]
    ```
    
- outí‚¤ì›Œë“œ ì‚¬ìš© ê°€ëŠ¥
    
    ```kotlin
    // You can add the â€œoutâ€ keyword to the type usage: no methods with T in the â€œinâ€ position are used.
    fun <T> copyData(
    	// type projection, outìœ„ì¹˜ì—ì„œë§Œ ì‚¬ìš©í•  ìˆ˜ ìˆìŒ, ë°˜í™˜íƒ€ì…
    	source: MutableList<out T>,
    	destination: MutableList<T>
    ) {
      for (item in source) {
          destination.add(item)
    	} 
    }
    
    // ì˜¤ë¥˜(ìƒí™©ì— ë”°ë¼ ì œë„¤ë¦­íƒ€ì… 2ê°œë¥¼ ì‚¬ìš©í•´ì•¼í•  ìˆ˜ë„ ìˆìŒ, outìœ„ì¹˜ê°€ ì•„ë‹Œ í•¨ìˆ˜ë¥¼ í˜¸ì¶œ í•´ì•¼í•  ê²½ìš°)
    >>> val list: MutableList<out Number> = ...
    >>> list.add(42)
    Error: Out-projected type 'MutableList<out Number>' prohibits
    the use of 'fun add(element: E): Boolean'
    
    // List<T>ì‚¬ìš©ì•ˆí•˜ëŠ”ê²Œ ì •ì„ì´ë‹¤
    ```
    
- projectioníƒ€ì… í•„ìš” ì—†ëŠ” ê²½ìš°ë„ ìˆë‹¤
    
    ```kotlin
    List<out T>
    List<T>
    ```
    
- in-projection
    
    ```kotlin
    // Tê°€ super type
    fun <T> copyData(
    	source: MutableList<T>,
    	destination: MutableList<in T>
    ) { // Allows the destination element type to be a supertype of the source element type
    	for (item in source) {
    		destination.add(item)
    	} 
    }
    
    // kotlin vs java
    // out
    // MutableList<out T>
    // MutableList<? extends T>
    
    // in
    // MutableList<in T> 
    // MutableList<? super T>.
    ```
    

## 9.3.6 ìŠ¤íƒ€ í”„ë¡œì ì…˜: íƒ€ì… ì¸ì ëŒ€ì‹  * ì‚¬ìš©

- Star Projection
    - ì œë„¤ë¦­ ì¸ìì— ëŒ€í•œ ì•„ë¬´ëŸ° ì •ë³´ê°€ ì—†ì„ ê²½ìš° ì‚¬ìš©
        - List<*>
    - List<*>
        - MutableList<*>ì€ MutableList<Any?>ê³¼ ë‹¤ë¥´ë‹¤
        - MutableList<Any?>
            - ì•„ë¬´ëŸ° ì›ì†Œ íƒ€ì…ì„ ê°€ì§ˆ ìˆ˜ ìˆìŒ
        - MutableList<*>
            - íŠ¹ì • íƒ€ì…ì˜ ì›ì†Œë¥¼ ê°–ê³  ìˆì§€ë§Œ ì–´ë–¤ íƒ€ì…ì¸ì§€ ëª¨ë¥¼ ê²½ìš°
            - ì›ì†Œë¥¼ ë„£ì„ ìˆ˜ëŠ” ì—†ì§€ë§Œ ê°€ì ¸ì˜¬ ìˆ˜ëŠ” ìˆë‹¤
                - ë¬´ì¡°ê±´ Any?ì¼ê²ƒì´ë¼ì„œ getì€ ê´œì°®ë‹¤
                
                ```kotlin
                >>> val list: MutableList<Any?> = mutableListOf('a', 1, "qwe")
                >>> val chars = mutableListOf('a', 'b', 'c')
                >>> val unknownElements: MutableList<*> = // MutableList<*> isnâ€™t the same as MutableList<Any?>.
                			if (Random().nextBoolean()) list else chars 
                >>> unknownElements.add(42)
                Error: Out-projected type 'MutableList<*>' prohibits
                the use of 'fun add(element: E): Boolean'
                >>> println(unknownElements.first())
                a
                ```
                
                - MutableList<*>ëŠ” out-projectedíƒ€ì…ì´ë‹¤
                    - MutableList<out Any?>ë¡œ ì·¨ê¸‰ëœë‹¤
                - kotlinê³¼ javaë¹„êµ
                    
                    ```kotlin
                    Kotlin: MyType<*> 
                    Java: MyType<?>.
                    ```
                    
    - Star Projectionì„ ì‚¬ìš©í•  ìˆ˜ ìˆëŠ” ê²½ìš°
        - íƒ€ì… íŒŒë¼ë¯¸í„°ê°€ ì¤‘ìš”í•˜ì§€ ì•Šë‹¤
        - ë°ì´í„°ë¥¼ ì½ê¸°ë§Œ í•˜ê³  íƒ€ì…ì— ëŒ€í•´ì„œëŠ” ìƒê´€ ì—†ì„ ê²½ìš°
            
            ```kotlin
            // ì›ì†Œ íƒ€ì…í•˜ê³  ìƒê´€ ì—†ì´ ì‚¬ìš© ê°€ëŠ¥
            fun printFirst(list: List<*>) {
                if (list.isNotEmpty()) { // isNotEmpty() doesnâ€™t use the generic type parameter.
                    println(list.first()) // first() now returns Any?, but in this case thatâ€™s enough.
                }
            }
            >>> printFirst(listOf("Svetlana", "Dmitry"))
            Svetlana
            ```
            
        - ì„ ì–¸ ì§€ì  ë³€ì„± declaration site variance, ëŒ€ì•ˆì´ ìˆë‹¤
            
            ```kotlin
            
            fun <T> printFirst(list: List<T>) { // Again, every list is a possible argument.
                if (list.isNotEmpty()) {
                    println(list.first()) // return T
                }
            }
            
            ```
            
        - ì‰½ê²Œ í‹€ë¦¬ê²Œ ì‚¬ìš©í•  ìˆ˜ ìˆëŠ” ìƒí™©
            
            ```kotlin
            // Interface declared as contravariant on T
            interface FieldValidator<in T> {
            		// T is used only in the â€œinâ€ position (this method consumes a value of T).
                fun validate(input: T): Boolean
            }
            object DefaultStringValidator : FieldValidator<String> {
                override fun validate(input: String) = input.isNotEmpty()
            }
            object DefaultIntValidator : FieldValidator<Int> {
                override fun validate(input: Int) = input >= 0
            }
            
            >>> val validators = mutableMapOf<KClass<*>, FieldValidator<*>>()
            >>> validators[String::class] = DefaultStringValidator
            >>> validators[Int::class] = DefaultIntValidator
            
            // *ì„ ë§µì— ë„£ì„ ë•Œ ì‚¬ìš©í–ˆë‹¤. ë°ì´í„°ë¥¼ ì½ì–´ ì˜¬ ë•Œ íƒ€ì… ì •ë³´ê°€ ì—†ë‹¤ 
            >>> validators[String::class]!!.validate("")
            Error: Out-projected type 'FieldValidator<*>' prohibits
            the use of 'fun validate(input: T): Boolean'
            
            // ìš°íšŒ(casting), íƒ€ì… ì†Œê±°ë¡œ ì¸í•˜ì—¬ ì›Œë‹, castingì‹œì  ë§ê³  ëŸ°íƒ€ì„ì—ì„œ ì‹¤íŒ¨, íƒ€ì…ì†Œê±°
            >>> val stringValidator = validators[String::class]
                                        as FieldValidator<String>
            >>> println(stringValidator.validate(""))
            false
            
            >>> val stringValidator = validators[Int::class]
                                        as FieldValidator<String> // ì»´íŒŒì¼ ê°€ëŠ¥
            >>> stringValidator.validate("") // ì§„ì§œ ì˜¤ë¥˜
            java.lang.ClassCastException:
              java.lang.String cannot be cast to java.lang.Number
              at DefaultIntValidator.validate
            ```
            
        - ì¡°ê¸ˆ ë” ì•ˆì „í•˜ê²Œ ì‚¬ìš©í•˜ëŠ” ë°©ë²•, íƒ€ì… ì„¸ì´í”„í•˜ê²Œ ì‚¬ìš©
            
            ```kotlin
            object Validators {
                private val validators =
                        mutableMapOf<KClass<*>, FieldValidator<*>>()
            
            fun <T: Any> registerValidator(
                    kClass: KClass<T>, fieldValidator: FieldValidator<T>) {
                validators[kClass] = fieldValidator
            }
            @Suppress("UNCHECKED_CAST")
            operator fun <T: Any> get(kClass: KClass<T>): FieldValidator<T> =
                validators[kClass] as? FieldValidator<T>
            ?: throw IllegalArgumentException( Suppresses the warning
            "No validator for ${kClass.simpleName}")
            }
            
            >>> Validators.registerValidator(String::class, DefaultStringValidator)
            >>> Validators.registerValidator(Int::class, DefaultIntValidator)
             9.4
            >>> println(Validators[String::class].validate("Kotlin"))
            true
            >>> println(Validators[Int::class].validate(42))
            true
            
            >>> println(Validators[String::class].validate(42))
            Error: The integer literal does not conform to the expected type String
            ```
            

# 9.4 ìš”ì•½

- abc